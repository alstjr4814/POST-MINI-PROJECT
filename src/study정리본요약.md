### 1. JS & 객체 지향 핵심 (Class & Object)

**[클래스와 인스턴스: 붕어빵 비유]**

- **클래스 (Class) = 설계도**: 붕어빵 기계.
- **인스턴스 (Instance) = 실체**: 기계에서 찍혀 나온 따끈따끈한 붕어빵.
- **인스턴스 변수 (Instance Variable) = 객체의 변수**:
- 만들어진 붕어빵 안에 들어있는 팥(Value). (객체마다 다름)

- **인스턴스 메서드 (Instance Method) = 객체의 함수**:
- 만들어진 붕어빵이 하는 행동. (예: `붕어빵.식다()`, `붕어빵.먹히다()`)

- **[참고: 메서드의 두 가지 스타일 (자판기 vs 로봇)]**
- **자판기형 (Return 있음)**: 돈을 넣으면 음료수를 뱉어냄. (예: `int add() { return a+b; }`)
- **행동대장형 (Void)**: 시키면 일만 하고 결과물은 안 줌. (영수증 없음)

Java

public class Robot {
    // void: 난 일만 하고 아무것도 안 돌려줄 거야.
    public void clean() {
            System.out.println("위잉~ 청소 중...");
            System.out.println("청소 끝!");
            // return이 없음!
    }
}
// 사용: Robot bot = new Robot();
// bot.clean(); // 변수에 담을 수 없음. 그냥 실행되고 끝.


- **정적 메서드 (Static Method) = 기계의 기능 (핵심)**:
- **개념**: 설계도(class) 자체에 붙어 있는 기능. 붕어빵이 만들어지기 전에도 기계는 이 기능을 가지고 있음. (예: `기계.만들기()`)
- **코드 예시**: `axios.create()` -> 공장(`axios`)이 가진 `create` 버튼을 눌러서 실체(`api`)를 만듦.



**[객체 안의 객체: '부품' 개념]**

- **구조**: `api`(객체) 안에는 문자열, 함수뿐만 아니라 **또 다른 객체(`interceptors`)**도 들어있다.
* **용어**: 이때, 객체 안에 들어있는 또 다른 객체를 개념적으로 **"구성 요소(Component)"** 혹은 **"모듈/부품"**이라고 부른다.
- *비유*: `api`를 자동차로 본다면, `interceptors`는 자동차 안에 장착된 **네비게이션이나 하이패스 단말기(부품)**와 같다.


- **접근**: 우리는 객체의 필드, 함수, 그리고 **객체 안의 객체(부품)**에도 점(`.`)을 찍어 접근한다. (예: `api.interceptors.request`)
- **프로퍼티 vs 메서드**:
- 객체 안에 있는 **변수(필드)** = **"프로퍼티 (Property)"**
- 객체 안에 있는 **함수** = **"메서드 (Method)"**
- 객체 안의 객체도 결국 **"프로퍼티"**다. (내용물이 객체일 뿐)



---

### 2. JS 문법 vs Java 비교 (Syntax & Comparison)

**[기본 문법 차이]**

- ** = (등호)**: 혼자 있을 때 씁니다. 변수 선언 (`const box = { ... }`)
- ** : (콜론)**: 객체 안에 들어 있을 때 씁니다. 프로퍼티 정의 (`target: { ... }`)
- **const**: 자료형이 아니라 **변수를 만드는 방식(키워드)**.
- *자바 비유*: `final`이다. (한 번 값을 넣으면 못 바꿈)


- **export**: 수출(내보내기).
- *자바 비유*: `public`과 같은 개념.


**[객체 구조와 HashMap]**

- **Java**:
- 설계도(Class)가 엄격함. 미리 적어두지 않은 필드는 못 넣음 (**엄격한 공장장**).
- 보통 `Map<String, String>`처럼 제네릭을 써서 타입과 키/값을 엄격하게 관리함.


- **JavaScript**:
- 설계도(Class)가 유연함. 나중에 막 갖다 붙여도 됨 (**대충 사는 공장장**).
- **JS 객체 `{}` = 자바의 `HashMap**`: 그냥 **데이터를 담는 바구니(Object Literal)**다. 함수 없이 필드만 담아도 완벽한 객체다.
- **Config의 정체**: `config`는 그냥 변수명(구성, 설정)이고, 그 실체는 설정을 담은 **보따리(객체)**다.



---

### 3. 네트워크 & 인증/인가 (Network & Auth)

**[인증 vs 인가]**

- **인증 (Authentication)**: **"너 누구야?"**
- *행동*: 아이디/비번 치고 로그인.
- *결과*: **신분증(토큰)을 발급받음**.
- *상황*: 공항 입국 심사대에서 여권 보여줌.


- **인가 (Authorization)**: **"너 이거 할 수 있어?"**
- *행동*: 글쓰기 버튼 누르기, 관리자 페이지 접속.
- *과정*: "어? 너 일반 회원이네? 못 들어가(403)."
- *상황*: 여권은 있지만 VIP 라운지에는 못 들어감.


- **코드 적용**: `config.headers.Authorization`에 토큰을 넣는 건, **"나 이 구역에 들어갈 권한(인가) 있어"**라고 증명하려고 신분증을 목에 거는 행위.

**[Bearer]**

- 약속된 암호. **"이건 Bearer(소지자) 토큰이야"**라고 명찰을 달아주는 것.

---

### 4. Axios 구조 및 원리 (Axios Structure)

**[Axios 생성과 흐름]**

1. **라이브러리 (Library)**: 남들이 힘들게 짜놓은 도구함. `import axios` 하는 순간 내 작업장으로 가져옴.
2. **`axios.create()`**:
- 단순히 URL만 저장하는 게 아님.
- "야, 내가 가진 기능(get, post, interceptors) 전부 복사해서 **새 로봇(인스턴스)** 하나 만들어. 단, 기본 목적지(`baseURL`)는 이걸로 설정해."


3. **`api` 변수 (결과물)**:
- 설정된 `baseURL`(데이터) + 통신 기능 `get/post`(함수) + 검문소 `interceptors`(객체)가 꽉 채워진 **종합 세트**.



**[Interceptors 작동 원리]**

- **구조**: `api`(자동차) -> `interceptors`(하이패스 단말기) -> `request`(입구 처리기) -> `use`(사용 버튼).
- **코드 의미**: `api.interceptors.request.use(...)`
- 하이패스 단말기에 **내 신용카드 정보(토큰)를 등록**하는 과정. 그래야 톨게이트 지날 때 자동으로 결제(인증) 되니까.


- **접근의 비밀**: `api`는 아빠(`axios`)의 유전자를 물려받았기 때문에, `api.interceptors`라고 점을 찍어서 그 장치에 접근 가능함.

**[Config와 Headers]**

- **Config**: 서버에 보낼 **편지 봉투(요청 보따리)**. URL, 메서드, 헤더 정보가 들어있음.
- **Headers**: 편지 봉투 겉면의 정보란. `config` 객체 안에 있는 **또 다른 작은 객체(프로퍼티)**.

**[백틱 (` `)]**

- 문자열과 변수 섞어 쓸 때(`+` 기호) 불편해서 사용.
- `${}`: 변수가 들어갈 구멍.

---

### 5. React 기초 & 파일별 분석 (React Fundamentals)

**[React 기초]**

- **React**: 데이터가 바뀔 때 화면을 자동으로 다시 그려주는 도구 (렌더링).
- **JSX**: JS 코드 안에서 HTML 태그처럼 생긴 걸 쓰고 싶어서 만든 문법.
- **Main.jsx**: 브라우저는 JSX를 못 읽음. 그래서 여기서 순수 JS로 변환해서 뿌려주는 **최종 조립 공장**.

**[파일별 핵심 역할]**

- **Main.jsx**:
- `BrowserRouter`: 주소 바뀌면 페이지 전체 새로고침 안 하고, 해당 화면 함수만 꺼내서 그려주는 감시 장치.
- `document.getElementById('root')`: `index.html` 설계도에서 `root`라는 도화지 구역을 찾아라.


- **App.jsx**:
- `<MainLayout>`: 백화점 공통 인테리어(복도, 화장실 등). 알맹이만 바뀌고 껍데기는 고정.
- `AuthRoute`: **핵심 로직**. 백엔드와 프론트엔드가 처음 만나는 **검문소**. 로그인 안 했으면 쫓아냄.


- **AuthRoute.jsx (경비실)**:
- `meQuery.isLoading`: 데이터 가져오는 중인가?
- `Maps`: 운전대. 주소를 강제로 바꿔서 이동시킴 (`/auth/login` 등으로).
- `location`: 내비게이션(GPS). 현재 내 위치 정보가 들어있음.
- `useEffect`: 감시 대상(`[pathname]`)이 변할 때마다 실행되는 녀석.

---

### 6. Java 심화: 익명 클래스, 람다 & 스트림 (Java Advanced)

**[익명 클래스 vs 람다식]**

- **익명 클래스 (Anonymous Class)**: **"일회용 컵"**
- 이름 짓기 귀찮아서 `new`와 동시에 `{}`를 열어 내용을 즉석에서 채워버린 객체.
- *단점*: 코드가 길고 파일은 안 만들어도 컴파일하면 임시 파일이 생김.

- **람다식 (Lambda)**: **"압축기"** (람다: 익명 함수를 뜻하는 수학 기호에서 유래)
- **원리 (추론과 생략)**: 어차피 인터페이스에 기능(함수)이 **딱 하나**뿐이라서, 컴퓨터가 무슨 함수인지 뻔히 안다.
- **결과**: `new`, 함수 이름, `return` 다 지우고 **`(재료) -> {결과}`** 알맹이만 남김.
- *조건*: **함수형 인터페이스(메서드가 1개인 놈)**만 사용 가능.

**[스트림 (Stream): 데이터 공장 자동화]**

- **개념**: 데이터를 하나하나 꺼내서(`for문`) 처리하는 게 아니라, **컨베이어 벨트** 위에 올려두고 공정별로 처리하는 방식.
- **3단계 공정**:
1. **생성**: 재료를 벨트에 올림 (`stream()`)
2. **가공**: 불량품 거르고, 포장지 바꿈 (`filter`, `map`) -> **여기서 람다식이 쓰임!**
3. **결과**: 최종 박스에 담음 (`collect`)

- **코드 해석 (파인만 기법)**:
```java
List<String> adultNames = users.stream() // 1. 컨베이어 벨트에 올린다.
    .filter(user -> user.getAge() >= 20) // 2. 필터(람다): 20세 미만은 탈락!
    .map(user -> user.getName())         // 3. 변신(람다): 사람 객체 -> 이름표(String)로 바꿈
    .collect(Collectors.toList());       // 4. 포장: 결과물을 리스트로 묶어서 배송.

7. Java 객체지향의 꽃: 인터페이스와 다형성 (Interface & Polymorphism)
[인터페이스 (Interface): 교체 가능한 부품 규격]

개념: **"USB 포트"**와 같다.

삼성 마우스든, 로지텍 마우스든 **꽂는 구멍(USB)**만 맞으면 컴퓨터는 신경 안 쓴다.

목적: 제조사(구현체)가 바뀌어도 컴퓨터 본체(Main)를 뜯어고치지 않기 위해 사용.

implements (구현):

사전적 의미: 시행하다, 이행하다.

코드적 의미: "나(Class)는 이 설계도(Interface)에 적힌 기능을 반드시 실행할 것을 맹세합니다." (서약서)

관습적으로 구현체 클래스 이름 뒤에 Impl을 붙인다. (예: MemberServiceImpl)

[다형성 (Polymorphism): "Main은 고민하지 않는다"]

핵심 코드:

Java

// [핵심] 자료형은 '규격(Mouse)'인데, 실체는 '삼성(Samsung)'이다.
Mouse myMouse = new SamsungMouse(); 
myMouse.click(); // 삼성 기술로 클릭됨

// 나중에 로지텍으로 부품 교체
myMouse = new LogitechMouse();
myMouse.click(); // 로지텍 기술로 클릭됨 (변수 myMouse는 건드릴 필요 없음!)
왜 이렇게 쓰는가? (Why):

**Main(사장님)**은 알바생 이름이 철수인지 영희인지 몰라도 된다.

그저 **"바코드 찍을 줄 알지?(Interface 기능)"**만 확인하면 바로 일을 시킬 수 있다.

이것이 나중에 배울 **Spring의 DI(의존성 주입)**가 가능한 근본적인 이유다.

[메서드와 리턴 타입의 비밀]

인터페이스가 **"강제"**하는 것:

메서드 이름: click() (이름 통일)

리턴 타입: void (결과물 형식 통일)

결과: 구현체(Impl)가 내부적으로 어떤 복잡한 지지고 볶는 로직을 짜든, 겉에서 볼 때는 **"똑같은 버튼"**으로 보인다.

[추가 팁: Stream의 마지막 퍼즐]

기존 6번 스트림 설명에 덧붙이는 개념

.collect() vs .forEach():

collect(): 완성된 붕어빵을 박스에 예쁘게 포장해서 사장님(변수)에게 바침. (Return O)

forEach(): 붕어빵이 나오는 족족 손님 입에 넣어버림 (출력, DB저장). 남는 게 없음. (Return X, void)

### 8. Spring Boot 생태계와 안전장치 (Spring Ecosystem & Safety)
[예외 처리 (Exception): 공장 비상 매뉴얼]

구조 (Try-Catch-Finally)

Try: "일단 위험한 작업(파일 열기, DB 접속) 시도해봐."

Catch: "불(에러) 났어? 소화기 뿌려!" (프로그램 셧다운 방지)

Finally: "성공하든 실패하든, 퇴근할 때 전원(Resource)은 끄고 가." (메모리 누수 방지, close())

두 가지 에러 종류 (면접 단골)

Unchecked (Runtime Exception): 실행 버튼 눌러야 터지는 폭탄.

원인: 개발자 실수 (예: NullPointerException - 빈 깡통 열기).

대처: 코드를 고쳐야 함.

Checked (Compile Exception): 빨간 줄 그어지는 에러.

원인: 외부 환경 문제 (파일 없음, DB 연결 끊김).

대처: 자바가 **"야, 이거 위험하니까 try-catch 안 쓰면 실행 안 시켜줘!"**라고 강제함.


[Throw & Global Handling: 책임 전가 시스템]

Throw: "이 에러, 내가 처리 안 해. 나를 부른 놈한테 던질 거야!"

Global Exception Handler:

각 기능(로그인, 회원가입)에서 자잘하게 에러를 잡지 않고, throw로 다 던져버림.

**전역 처리기(청소부 클래스)**가 공중에서 에러를 낚아채서 한 번에 깔끔하게 처리함.

목적: 비즈니스 로직(핵심 기능)을 깔끔하게 유지하기 위함.

[JPA & Jackson: 자동화 로봇과 통역사]Jackson (통역사): JSON $\leftrightarrow$ JavaJSON: 인터넷 택배용 주문서(텍스트). ("{ name: 철수 }")Java Object: 주방에서 요리하는 실체(메모리). (User 객체)역할: 종이(JSON)를 보고 실제 요리(Java)를 만들어내거나, 그 반대를 수행.JPA (창고지기 로봇): Java $\leftrightarrow$ DB개발자가 save(user)만 하면, 로봇이 알아서 SQL을 짜서 DB에 넣음.매개체 (@Entity): 클래스에 붙은 스티커가 DB 테이블과 연결되는 지도(Map) 역할.NoArgs Constructor (빈 깡통 생성자)의 비밀Jackson과 JPA는 일단 **빈 깡통(new User())**을 먼저 만듦. (필수!)데이터(JSON, DB)를 보고 깡통 안을 채워 넣음 (Reflection 마법).

[개발 도구 삼형제: Maven, Annotation, Lombok]

Maven/Gradle (사서): 인터넷 도서관에서 라이브러리를 다운로드해 주는 역할.

Annotation (@) (주문서/스티커):

**"이거 이렇게 처리해 주세요"**라고 도구에게 명령하는 메모지.

오해 금지: @을 쓴다고 자동 import 되는 게 아님. IDE가 보고 도와주는 것.

Lombok (유령 작가):

컴파일 시 @Data, @Builder 등을 보고 Getter, Setter 코드를 몰래 작성함.

주의: 생성자 조건에 따라 @AllArgsConstructor 등이 따로 필요할 수 있음.